# This is a basic workflow to help you get started with Actions

name: NewReleaseCheckout

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  schedule:
    - cron: '*/3 * * * *'  # Runs every 30 minutes

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    steps:
    
      - name: Checkout tools current repo
        uses: actions/checkout@v4
        with:
          repository: ALPHA-Charlott/repo
          token: ${{ secrets.API_TOKEN }}
          
      - name: Get latest release
        id: get_latest_release
        env:
          TARGET_REPO: "ALPHA-Charlott/azure-monitor-baseline-alerts"  # Replace with the public repo owner and name
        run: |
          function is_in_remote() {
              local branch=${1}
              local existed_in_remote=$(git ls-remote --heads origin ${branch})
          
              if [[ -z ${existed_in_remote} ]]; then
                  echo 0
              else
                  echo 1
              fi
          }
          response=$(curl -L -H "Accept: application/vnd.github+json" -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/${TARGET_REPO}/releases/latest)
          echo "$response" > response.json
          GH_TAG_NAME=$(jq -r '.tag_name' response.json)
          GH_HTML_URL=$(jq -r '.html_url' response.json)
          echo "GH_TAG_NAME=${GH_TAG_NAME}" >> $GITHUB_OUTPUT
          echo "GH_HTML_URL=${GH_HTML_URL}" >> $GITHUB_OUTPUT
          echo "GH_REL=${GH_TAG_NAME}" >> $GITHUB_ENV
          echo "GH_REL_URL=${GH_HTML_URL}" >> $GITHUB_ENV

      - name: Parse Nested Field with jq
        id: parse_field
        run: |
          echo "${{ env.URL }}" "HTML_URL >>>>"
          echo ${{ steps.get_latest_release.outputs.GH_TAG_NAME }}
          echo ${{ steps.get_latest_release.outputs.GH_HTML_URL }}
          
      - name: creating issues for track the merge request discussion
        uses: dacbd/create-issue-action@main
        with:
          token: ${{ secrets.API_TOKEN }}
          title: |
             failed during
            # Auto-assign person who triggered the failure.
          assignees: ${{ github.actor }},${{ github.triggering_actor }}
          labels: RELEASE_SYNC
          body: |
            ## Merging new release into local repository
        ##
      - name: checkout latest release(tag)
        uses: actions/checkout@v4
        with:
          repository: ${{ vars.REMOTE_REPO }}
          ref: "refs/tags/${{ steps.get_latest_release.outputs.GH_TAG_NAME }}"
        
      # Step 3: Make any changes you want her  Commit the changes (if any)
      - name: Create a new branch from checked-out commit
        run: |
          git checkout -b new-release
          git config --global user.name "github_bot"
          git config --global user.email "bot@noreply.github.com"
          # git remote add upstream https://github.com/ALPHA-Charlott/azure-monitor-baseline-alerts.git
          # git commit -m "NEW Release ${{ steps.get_latest_release.outputs.GH_TAG_NAME }}"
          # git push origin new-release
          
      - name: Create Pull Request
        id: cpr
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}  # Target repository where the PR will go (original repository)
          base: main  # Or the branch you want to merge into in the original repository
          head: new-release  # The source branch from the other repository (the one you checked out)
          title: 'Your PR Title'
          body: 'Description of the changes made in this PR'
          
      # - name: Create Pull Request
      #   id: cpr
      #   uses: peter-evans/create-pull-request@v7


        
      # - name: checkout latest release(tag)
      #   uses: actions/checkout@v4
      #   with:
      #     repository: ${{ vars.REMOTE_REPO }}
      #     ref: 'V0.0.1'
            
      # - name: Create Pull Request
      #   id: cpr
      #   uses: peter-evans/create-pull-request@v7
        
      # - name: Check outputs
      #   if: ${{ steps.cpr.outputs.pull-request-number }}
      #   run: |
      #     echo "Pull Request Number - ${{ steps.cpr.outputs.pull-request-number }}"
      #     echo "Pull Request URL - ${{ steps.cpr.outputs.pull-request-url }}"
          
      # - name: Parse Nested Field with jq
      #   id: parse_field
      #   run: |
      #     # Use jq to access the nested field, replacing 'outerField.nestedField' with your actual path
      #     cat response.json
      #     # GH_TAG_NAME=$(jq -r '.tag_name' response.json)
      #     # GH_HTML_URL=$(jq -r '.html_url' response.json)
      #     # # echo "Nested Field 1: ${GH_TAG_NAME}"
      #     echo "Nested Field 2: $GH_HTML_URL"
      #     # echo "::set-output name=GH_TAG_NAME::$GH_TAG_NAME"
      #     # echo "GH_TAG_NAME=$GH_TAG_NAME" >> $GITHUB_OUTPUT
      #     # echo "GH_HTML_URL=${{ GH_HTML_URL }}" >> $GITHUB_OUTPUT
          

  
      # - name: Fetch Specific Tag from Remote Repository
      #   run: |
      #     git remote add upstream https://github.com/ALPHA-Charlott/azure-monitor-baseline-alerts.git
      #     git fetch upstream refs/tags/${{ github.event.inputs.tag_name }}:refs/tags/${{ github.event.inputs.tag_name }}

      # - name: Push Tag to Local Repository
      #   run: |
      #     git push origin refs/tags/${{ github.event.inputs.tag_name }}
          
      #     repository: 
          
      # - name: make sure there is no current repo
      #   env:
      #     REPO: ALPHA-Charlott/repo
      #   run: |
      #     function is_in_remote() {
      #         local branch=${1}
      #         local existed_in_remote=$(git ls-remote --heads origin ${branch})
          
      #         if [[ -z ${existed_in_remote} ]]; then
      #             echo 0
      #         else
      #             echo 1
      #         fi
      #     }
          
      # - name: Get latest release
      #   id: get_release
      #   env:
      #     REPO: "owner/public-repo-name"  # Replace with the public repo owner and name
      #   run: |
      #     function is_in_remote() {
      #         local branch=${1}
      #         local existed_in_remote=$(git ls-remote --heads origin ${branch})
          
      #         if [[ -z ${existed_in_remote} ]]; then
      #             echo 0
      #         else
      #             echo 1
      #         fi
      #     }
